// =============================================================================
// Copyright 2006-2010 Daniel W. Dyer
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// =============================================================================
package org.processmining.plugins.etm.mutation;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import org.processmining.plugins.etm.CentralRegistry;
import org.processmining.plugins.etm.model.narytree.NAryTree;
import org.processmining.plugins.etm.model.narytree.NAryTreeImpl;
import org.uncommons.maths.random.Probability;
import org.uncommonseditedbyjoosbuijs.watchmaker.framework.operators.AbstractCrossover;

/**
 * Cross-over operator for the trees of {@link Node}s.
 * 
 * @author jbuijs
 */
// FIXME check all class contents
// FIXME UNTESTED code
public class TreeCrossover<R extends NAryTree> extends AbstractCrossover<NAryTree> {
	/*-
	private final double crossoverProbability;
	
	public TreeCrossover(double crossoverProbability) {
		super(1, crossoverProbability);
		this.crossoverProbability = crossoverProbability;
	}/**/

	CentralRegistry registry;

	public TreeCrossover(int crossoverPoints, Probability crossoverProbability, CentralRegistry registry) {
		super(crossoverPoints, crossoverProbability);
		this.registry = registry;
	}

	/**
	 * Swaps randomly selected sub-trees between the two parents.
	 * 
	 * @param parent1
	 *            The first parent.
	 * @param parent2
	 *            The second parent.
	 * @param numberOfCrossoverPoints
	 *            The number of cross-overs to perform.
	 * @param rng
	 *            A source of randomness.
	 * @return A list of two offspring, generated by swapping sub-trees between
	 *         the two parents.
	 */
	@Override
	protected List<NAryTree> mate(NAryTree parent1, NAryTree parent2, int numberOfCrossoverPoints, Random rng) {
		NAryTree tree1 = new NAryTreeImpl(parent1);
		NAryTree tree2 = new NAryTreeImpl(parent2);

		assert tree1.isConsistent();
		assert tree2.isConsistent();

		//Prepare the offspring list
		List<NAryTree> offspring = new ArrayList<NAryTree>(2);

		//Now apply crossover as many times as required
		for (int i = 0; i < numberOfCrossoverPoints; i++) {
			//Find random crossover points
			int pointTree1 = rng.nextInt(tree1.size());
			int pointTree2 = rng.nextInt(tree2.size());

			//Now apply the swap but create 2 new trees otherwise the 2nd swap swaps a different node than intended
			NAryTree t1new = tree1.replace(pointTree1, tree2, pointTree2);
			NAryTree t2new = tree2.replace(pointTree2, tree1, pointTree1);

			assert t1new.isConsistent();
			assert t2new.isConsistent();

			//Update the pointers
			tree1 = t1new;
			tree2 = t2new;

			// Update history
			if (parent1.isLeaf(pointTree1)) {
				pointTree1 = parent1.getParentFast(pointTree1);
			}
			if (parent2.isLeaf(pointTree2)) {
				pointTree2 = parent2.getParentFast(pointTree2);
			}
			/*-
			// FIXME JBUIJS DISABLED MIGRATION FROM BORJA CODE
			registry.saveHistory(tree1, parent1, TreeUtilsAlignmentRepair.replaceWithParentType(pointTree1, NAryTree.LOOP, parent1),
				NAryTreeHistory.TypesOfChange.OTHER);
			registry.saveHistory(tree2, parent2, TreeUtilsAlignmentRepair.replaceWithParentType(pointTree2, NAryTree.LOOP, parent2),
				NAryTreeHistory.TypesOfChange.OTHER);/**/
		}

		offspring.add(tree1);
		offspring.add(tree2);
		return offspring;
	}
}
